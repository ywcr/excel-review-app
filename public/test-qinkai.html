<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æµ‹è¯•ç§¦å‡¯æ–‡ä»¶è§£æ</title>
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
</head>
<body>
    <h1>æµ‹è¯•ç§¦å‡¯æ–‡ä»¶è§£æ</h1>
    <button onclick="testQinkaiFile()">æµ‹è¯•ç§¦å‡¯æ‹œè®¿.xlsx</button>
    <div id="result"></div>

    <script>
        async function testQinkaiFile() {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = '<p>æ­£åœ¨æµ‹è¯•ç§¦å‡¯æ–‡ä»¶...</p>';
            
            try {
                // åŠ è½½ç§¦å‡¯æ–‡ä»¶
                const response = await fetch('/data/ç§¦å‡¯æ‹œè®¿.xlsx');
                if (!response.ok) {
                    throw new Error(`æ–‡ä»¶åŠ è½½å¤±è´¥: ${response.status}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                console.log('æ–‡ä»¶å¤§å°:', (arrayBuffer.byteLength / 1024 / 1024).toFixed(2), 'MB');
                
                // æµ‹è¯•1: ç›´æ¥è§£æï¼ˆç±»ä¼¼æµ‹è¯•æ–‡ä»¶çš„æ–¹å¼ï¼‰
                resultDiv.innerHTML += '<h2>æµ‹è¯•1: ç›´æ¥è§£æ</h2>';
                
                try {
                    const workbook = XLSX.read(arrayBuffer, {
                        type: "array",
                        cellDates: true,
                        dense: false,
                        sheetStubs: false,
                        bookVBA: false,
                        bookProps: false,
                        bookFiles: false,
                        bookDeps: false,
                        raw: false
                    });
                    
                    resultDiv.innerHTML += '<p style="color: green;">âœ… ç›´æ¥è§£ææˆåŠŸ!</p>';
                    resultDiv.innerHTML += `<p>å·¥ä½œè¡¨: ${workbook.SheetNames.join(', ')}</p>`;
                    
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const data = XLSX.utils.sheet_to_json(firstSheet, {
                        header: 1,
                        defval: "",
                        raw: false,
                        dateNF: "yyyy-mm-dd"
                    });
                    
                    resultDiv.innerHTML += `<p>æ€»è¡Œæ•°: ${data.length}</p>`;
                    resultDiv.innerHTML += `<p>å·¥ä½œè¡¨èŒƒå›´: ${firstSheet['!ref'] || 'æ— '}</p>`;
                    
                    // æ˜¾ç¤ºå‰å‡ è¡Œæ•°æ®
                    resultDiv.innerHTML += '<h3>å‰5è¡Œæ•°æ®:</h3>';
                    for (let i = 0; i < Math.min(5, data.length); i++) {
                        const row = data[i];
                        resultDiv.innerHTML += `<p>ç¬¬${i+1}è¡Œ: ${JSON.stringify(row?.slice(0, 5) || [])}</p>`;
                    }
                    
                } catch (error) {
                    resultDiv.innerHTML += `<p style="color: red;">âŒ ç›´æ¥è§£æå¤±è´¥: ${error.message}</p>`;
                    console.error('ç›´æ¥è§£æé”™è¯¯:', error);
                }
                
                // æµ‹è¯•2: ä½¿ç”¨å½“å‰Workerçš„è§£æé€‰é¡¹
                resultDiv.innerHTML += '<h2>æµ‹è¯•2: Workerè§£æé€‰é¡¹</h2>';
                
                try {
                    const parseOptions = {
                        type: "array",
                        cellDates: true,
                        cellNF: false,
                        cellText: false,
                        dense: false,
                        sheetStubs: false,
                        bookVBA: false,
                        bookSheets: false,
                        bookProps: false,
                        bookFiles: false,
                        bookDeps: false,
                        raw: false,
                    };
                    
                    console.log('Workerè§£æé€‰é¡¹:', parseOptions);
                    const workbook2 = XLSX.read(arrayBuffer, parseOptions);
                    
                    resultDiv.innerHTML += '<p style="color: green;">âœ… Workeré€‰é¡¹è§£ææˆåŠŸ!</p>';
                    resultDiv.innerHTML += `<p>å·¥ä½œè¡¨: ${workbook2.SheetNames.join(', ')}</p>`;
                    resultDiv.innerHTML += `<p>Sheetså¯¹è±¡: ${workbook2.Sheets ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'}</p>`;
                    
                    if (workbook2.Sheets) {
                        resultDiv.innerHTML += `<p>å¯ç”¨å·¥ä½œè¡¨: ${Object.keys(workbook2.Sheets).join(', ')}</p>`;
                        
                        const firstSheet2 = workbook2.Sheets[workbook2.SheetNames[0]];
                        if (firstSheet2) {
                            resultDiv.innerHTML += `<p>ç¬¬ä¸€ä¸ªå·¥ä½œè¡¨èŒƒå›´: ${firstSheet2['!ref'] || 'æ— '}</p>`;
                            
                            const data2 = XLSX.utils.sheet_to_json(firstSheet2, {
                                header: 1,
                                defval: "",
                                raw: false,
                                dateNF: "yyyy-mm-dd"
                            });
                            
                            resultDiv.innerHTML += `<p>æ•°æ®è¡Œæ•°: ${data2.length}</p>`;
                        }
                    }
                    
                } catch (error) {
                    resultDiv.innerHTML += `<p style="color: red;">âŒ Workeré€‰é¡¹è§£æå¤±è´¥: ${error.message}</p>`;
                    console.error('Workeré€‰é¡¹è§£æé”™è¯¯:', error);
                }
                
                // æµ‹è¯•3: ä½¿ç”¨WorkeréªŒè¯
                resultDiv.innerHTML += '<h2>æµ‹è¯•3: WorkeréªŒè¯</h2>';
                
                const worker = new Worker('/validation-worker.js');
                
                worker.onmessage = (e) => {
                    const { type, data } = e.data;
                    console.log('Workeræ¶ˆæ¯:', type, data);
                    
                    if (type === 'PROGRESS') {
                        resultDiv.innerHTML += `<p>è¿›åº¦: ${data.message} (${data.progress}%)</p>`;
                    } else if (type === 'RESULT') {
                        if (data && data.needSheetSelection) {
                            resultDiv.innerHTML += '<p style="color: orange;">ğŸ”„ éœ€è¦ç”¨æˆ·é€‰æ‹©å·¥ä½œè¡¨</p>';
                            resultDiv.innerHTML += '<p>å¯ç”¨å·¥ä½œè¡¨:</p>';
                            resultDiv.innerHTML += '<ul>';
                            data.availableSheets.forEach(sheet => {
                                resultDiv.innerHTML += `<li>${sheet.name} (${sheet.hasData ? 'æœ‰æ•°æ®' : 'æ— æ•°æ®'})</li>`;
                            });
                            resultDiv.innerHTML += '</ul>';
                        } else {
                            resultDiv.innerHTML += '<p style="color: green;">âœ… WorkeréªŒè¯æˆåŠŸ!</p>';
                            resultDiv.innerHTML += '<h3>éªŒè¯ç»“æœè¯¦æƒ…:</h3>';

                            // æ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯
                            if (data.summary) {
                                resultDiv.innerHTML += `<p><strong>æ€»è¡Œæ•°:</strong> ${data.summary.totalRows}</p>`;
                                resultDiv.innerHTML += `<p><strong>æœ‰æ•ˆè¡Œæ•°:</strong> ${data.summary.validRows}</p>`;
                                resultDiv.innerHTML += `<p><strong>é”™è¯¯æ•°é‡:</strong> ${data.summary.errorCount}</p>`;
                            }

                            // æ˜¾ç¤ºè¡¨å¤´éªŒè¯
                            if (data.headerValidation) {
                                resultDiv.innerHTML += '<h4>è¡¨å¤´éªŒè¯:</h4>';
                                resultDiv.innerHTML += `<p>è¡¨å¤´æœ‰æ•ˆ: ${data.headerValidation.isValid ? 'âœ…' : 'âŒ'}</p>`;
                                if (data.headerValidation.missingFields && data.headerValidation.missingFields.length > 0) {
                                    resultDiv.innerHTML += `<p>ç¼ºå¤±å­—æ®µ: ${data.headerValidation.missingFields.join(', ')}</p>`;
                                }
                            }

                            // æ˜¾ç¤ºé”™è¯¯è¯¦æƒ…
                            if (data.errors && data.errors.length > 0) {
                                resultDiv.innerHTML += '<h4>éªŒè¯é”™è¯¯:</h4>';
                                resultDiv.innerHTML += `<p>å…± ${data.errors.length} ä¸ªé”™è¯¯</p>`;
                                resultDiv.innerHTML += '<ul>';
                                data.errors.slice(0, 10).forEach(error => {
                                    resultDiv.innerHTML += `<li>ç¬¬${error.row}è¡Œ ${error.column}åˆ—: ${error.message}</li>`;
                                });
                                if (data.errors.length > 10) {
                                    resultDiv.innerHTML += `<li>... è¿˜æœ‰ ${data.errors.length - 10} ä¸ªé”™è¯¯</li>`;
                                }
                                resultDiv.innerHTML += '</ul>';
                            } else {
                                resultDiv.innerHTML += '<p style="color: green;">ğŸ‰ æ²¡æœ‰å‘ç°éªŒè¯é”™è¯¯ï¼</p>';
                            }

                            // æ˜¾ç¤ºå›¾ç‰‡éªŒè¯ç»“æœ
                            if (data.imageValidation) {
                                resultDiv.innerHTML += '<h4>å›¾ç‰‡éªŒè¯:</h4>';
                                resultDiv.innerHTML += `<p>æ€»å›¾ç‰‡æ•°: ${data.imageValidation.totalImages}</p>`;
                                resultDiv.innerHTML += `<p>æ¨¡ç³Šå›¾ç‰‡: ${data.imageValidation.blurryImages}</p>`;
                                resultDiv.innerHTML += `<p>é‡å¤å›¾ç‰‡ç»„: ${data.imageValidation.duplicateGroups}</p>`;
                            }

                            // æ˜¾ç¤ºå®Œæ•´çš„åŸå§‹æ•°æ®ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                            resultDiv.innerHTML += '<details><summary>å®Œæ•´éªŒè¯ç»“æœï¼ˆè°ƒè¯•ç”¨ï¼‰</summary>';
                            resultDiv.innerHTML += `<pre>${JSON.stringify(data, null, 2)}</pre>`;
                            resultDiv.innerHTML += '</details>';
                        }
                        worker.terminate();
                    } else if (type === 'ERROR') {
                        resultDiv.innerHTML += `<p style="color: red;">âŒ WorkeréªŒè¯å¤±è´¥: ${data.message}</p>`;
                        worker.terminate();
                    }
                };
                
                worker.onerror = (error) => {
                    resultDiv.innerHTML += `<p style="color: red;">âŒ Workeré”™è¯¯: ${error.message}</p>`;
                };
                
                // å‘é€éªŒè¯è¯·æ±‚
                worker.postMessage({
                    type: 'VALIDATE_EXCEL',
                    data: {
                        fileBuffer: arrayBuffer,
                        taskName: 'yuyuan',
                        selectedSheet: undefined,
                        template: {
                            requiredFields: ['åºå·', 'ä»»åŠ¡æ ‡é¢˜', 'å®æ–½äºº', 'å¯¹æ¥äºº', 'é›¶å”®æ¸ é“'],
                            sheetNames: ['Sheet1', 'è¯åº—æ‹œè®¿', 'æ‹œè®¿è®°å½•'],
                            name: 'è¯åº—æ‹œè®¿è®°å½•éªŒè¯'
                        },
                        includeImages: false
                    }
                });
                
            } catch (error) {
                console.error('æµ‹è¯•é”™è¯¯:', error);
                resultDiv.innerHTML += `<p style="color: red;">æµ‹è¯•å¤±è´¥: ${error.message}</p>`;
            }
        }
    </script>
</body>
</html>
