# 代码改进方案

## 🔍 发现的主要问题

### 1. 依赖管理问题
**问题**: `AutomationCodeGenerator` 构造函数中直接创建了5个依赖对象
```javascript
constructor(config) {
    this.config = config;
    this.templateManager = new TemplateManager();           // 硬依赖
    this.validationManager = new ValidationManager();       // 硬依赖
    this.executionLogicManager = new ExecutionLogicManager(); // 硬依赖
    this.controlPanelManager = new ControlPanelManager();   // 硬依赖
    this.questionnaireLogic = QuestionnaireLogicFactory.create(config.name); // 硬依赖
}
```

**影响**: 
- 难以进行单元测试
- 无法替换依赖实现
- 违反了依赖倒置原则

### 2. 模板重复问题
**问题**: API和DOM模板有大量重复内容
```javascript
getApiAllDatesTemplate() {
    return this.getApiSingleTemplate()
        .replace('API模式自动化执行代码（增强版）', 'API模式自动化执行代码（全部日期）')
        .replace('包含功能: 自动化创建 + 数据验证 + 缺失补充', '包含功能: 自动化创建 + 数据验证 + 日期切换');
}
```

**影响**:
- 维护困难
- 容易出错
- 代码冗余

### 3. 职责混乱问题
**问题**: 某些类承担了过多职责
- `BaseQuestionnaire` 既管理问卷逻辑，又管理联系人创建，还管理医院创建
- `AutomationCodeGenerator` 既生成代码，又负责复制到剪贴板

## 🛠️ 具体改进方案

### 方案1: 依赖注入重构

创建依赖注入容器：
```javascript
// 新建 html/js/automation/dependency-container.js
class DependencyContainer {
    constructor() {
        this.dependencies = new Map();
        this.singletons = new Map();
    }
    
    register(name, factory, singleton = false) {
        this.dependencies.set(name, { factory, singleton });
    }
    
    resolve(name) {
        const dep = this.dependencies.get(name);
        if (!dep) throw new Error(`Dependency not found: ${name}`);
        
        if (dep.singleton) {
            if (!this.singletons.has(name)) {
                this.singletons.set(name, dep.factory(this));
            }
            return this.singletons.get(name);
        }
        
        return dep.factory(this);
    }
}

// 配置依赖
const container = new DependencyContainer();
container.register('templateManager', () => new TemplateManager(), true);
container.register('validationManager', () => new ValidationManager(), true);
container.register('executionLogicManager', () => new ExecutionLogicManager(), true);
container.register('controlPanelManager', () => new ControlPanelManager(), true);
```

重构代码生成器：
```javascript
class AutomationCodeGenerator {
    constructor(config, container = null) {
        this.config = config;
        this.container = container || new DependencyContainer();
        
        // 延迟加载依赖
        this._templateManager = null;
        this._validationManager = null;
        this._executionLogicManager = null;
        this._controlPanelManager = null;
        this._questionnaireLogic = null;
    }
    
    get templateManager() {
        if (!this._templateManager) {
            this._templateManager = this.container.resolve('templateManager');
        }
        return this._templateManager;
    }
    
    // 其他依赖类似处理...
}
```

### 方案2: 模板系统重构

创建模板基类和扩展：
```javascript
// 新建 html/js/automation/template-base.js
class TemplateBase {
    constructor() {
        this.placeholders = new Set();
    }
    
    getBaseTemplate() {
        return `
// ==================== {{MODE}}模式自动化执行代码{{TYPE_SUFFIX}} ====================
// 执行人: {{ASSIGNEE}}
{{DATE_COMMENT}}
// 包含功能: {{FEATURES}}

const data = {{DATA}};
const config = {{CONFIG}};
const hasChannel = {{HAS_CHANNEL}};

console.log("数据加载完成，共", data.length, "条");

{{MODE_SPECIFIC_CONFIG}}

{{VALIDATION_CODE}}

{{MODE_SPECIFIC_FUNCTIONS}}

{{QUESTION_LOGIC}}

{{EXECUTION_LOGIC}}

{{STARTUP_MESSAGES}}

{{CONTROL_PANEL}}
`;
    }
    
    createTemplate(mode, type, features) {
        const template = this.getBaseTemplate();
        const replacements = this.getReplacements(mode, type, features);
        
        return this.applyReplacements(template, replacements);
    }
}

class DomTemplateExtension extends TemplateBase {
    getModeSpecificConfig() {
        return `
// DOM操作相关变量
const contentWindow = document.querySelector('#ssfwIframe')?.contentWindow ?? window;

// API基础配置（用于验证功能）
const API_BASE_URL = window.location.origin;
`;
    }
    
    getModeSpecificFunctions() {
        return `
// 设置输入框值
function setInputValue(name, value) {
    // DOM操作逻辑
}

// 设置选项值  
function setOptionValue(index, values) {
    // DOM操作逻辑
}
`;
    }
}
```

### 方案3: 职责分离重构

拆分 `BaseQuestionnaire`：
```javascript
// 新建 html/js/automation/questionnaire-logic/questionnaire-interface.js
class IQuestionnaire {
    getQuestionLogic() {
        throw new Error('Must implement getQuestionLogic');
    }
}

// 新建 html/js/automation/contact-manager.js
class ContactManager {
    constructor(contactType) {
        this.contactType = contactType;
    }
    
    getContactCreationLogic() {
        // 联系人创建逻辑
    }
}

// 新建 html/js/automation/channel-manager.js
class ChannelManager {
    constructor(hasChannel) {
        this.hasChannel = hasChannel;
    }
    
    getChannelCreationLogic() {
        // 医院创建逻辑
    }
}

// 重构后的基类
class BaseQuestionnaire extends IQuestionnaire {
    constructor(config) {
        super();
        this.config = config;
        this.contactManager = new ContactManager(config.contactType);
        this.channelManager = new ChannelManager(config.hasChannel);
    }
    
    getContactCreationLogic() {
        return this.contactManager.getContactCreationLogic();
    }
    
    getChannelCreationLogic() {
        return this.channelManager.getChannelCreationLogic();
    }
}
```

### 方案4: 配置外部化

创建配置管理器：
```javascript
// 新建 html/js/automation/config-manager.js
class ConfigManager {
    constructor() {
        this.configs = new Map();
        this.loadConfigs();
    }
    
    loadConfigs() {
        // 从外部文件或API加载配置
        this.loadTemplateConfigs();
        this.loadValidationConfigs();
        this.loadExecutionConfigs();
    }
    
    getTemplateConfig(templateName) {
        return this.configs.get(`template.${templateName}`);
    }
    
    getValidationConfig() {
        return this.configs.get('validation');
    }
}
```

## 📋 实施计划

### 阶段1: 立即改进（1-2天）
1. ✅ 补充其他问卷类型的逻辑实现
2. ✅ 统一错误处理机制
3. ✅ 添加输入参数验证

### 阶段2: 结构优化（3-5天）
1. 🔄 实施依赖注入重构
2. 🔄 重构模板系统
3. 🔄 职责分离重构

### 阶段3: 架构升级（1-2周）
1. ⏳ 配置外部化
2. ⏳ 添加单元测试
3. ⏳ 性能优化

## 🎯 预期收益

### 短期收益
- 代码更易测试
- 依赖关系更清晰
- 模板维护更简单

### 长期收益
- 系统更易扩展
- 配置更灵活
- 维护成本更低

## 🤔 是否需要立即实施？

**建议**: 
1. **立即实施阶段1**: 风险低，收益明显
2. **评估后实施阶段2**: 需要考虑开发时间和测试成本
3. **谨慎考虑阶段3**: 可能过度设计，需要根据实际需求决定

当前重构已经解决了主要问题，是否进一步优化需要权衡成本和收益。
