# 签名算法优化说明

## 概述

基于对 `lgb/xfzwj/add` 接口完整请求流程的分析，对 `automation-generator.js` 中的签名相关代码进行了全面优化，确保与后端 `crypto.js` 实现保持一致。

## 主要优化内容

### 1. 签名算法实现优化

#### 原始实现问题：

- 使用简单的 MD5 哈希算法
- 签名逻辑与后端不一致
- 缺少 HMAC-SHA256 实现

#### 优化后实现：

```javascript
// SHA-256 实现
function sha256(data) {
  // 优先使用CryptoJS，如果不可用则使用备用实现
  if (typeof CryptoJS !== "undefined" && CryptoJS.SHA256) {
    return CryptoJS.SHA256(data).toString();
  } else {
    // 简化的SHA-256实现
    // ...
  }
}

// HMAC-SHA256 实现
function hmac(key, data) {
  // 完整的HMAC-SHA256算法实现
  // 包括key长度处理、内部外部填充等
}

// 签名函数
function sign(inputKey, inputData) {
  const encoder = new TextEncoder("utf-8");
  const key =
    typeof inputKey === "string" ? encoder.encode(inputKey) : inputKey;
  const data =
    typeof inputData === "string" ? encoder.encode(inputData) : inputData;
  return hmac(key, data);
}
```

### 2. 动态盐值获取优化

#### 原始实现：

- 简单的 fetch 调用
- 缺少错误处理

#### 优化后实现：

```javascript
async function createDynamicsSalt() {
  try {
    const response = await fetch(
      `${API_BASE_URL}/lgb/payMerge/createDynamicsSalt?methodName=%2Fxfzwj%2Fadd`,
      {
        method: "GET",
        headers: {
          accept: "*/*",
          "accept-language": "zh-CN,zh;q=0.9",
          "sec-ch-ua":
            '"Not;A=Brand";v="99", "Google Chrome";v="139", "Chromium";v="139"',
          "sec-ch-ua-mobile": "?0",
          "sec-ch-ua-platform": '"macOS"',
          "sec-fetch-dest": "empty",
          "sec-fetch-mode": "cors",
          "sec-fetch-site": "same-origin",
          "x-requested-with": "XMLHttpRequest",
        },
        credentials: "include",
      }
    );

    const result = await response.json();
    if (result.code === 0) {
      console.log("✅ 动态盐值获取成功:", result.data);
      return result.data;
    } else {
      throw new Error(`获取动态盐值失败: ${result.message}`);
    }
  } catch (error) {
    console.error("❌ 获取动态盐值失败:", error);
    throw error;
  }
}
```

### 3. 数据格式化优化

#### 关键改进：

- 使用 `encryptedText` 进行签名（与后端 `dcwj.js` 一致）
- 正确的参数编码和格式化
- 与后端 `formatParams` 和 `toQueryString` 函数保持一致

```javascript
// 构建encryptedText（用于签名）
const encryptedText = `${answerParams}answers=${encodeURIComponent(
  answerString
)}&corpId=${CORP_ID}&dcdxName=${encodeURIComponent(
  name
)}&isForward=1&memo=${encodeURIComponent(
  "为了充分了解客户对于西黄丸产品评价，为更好的做好临床药学服务，促进产品在临床的安全合理的使用，便于下一步市场策略的规划，特进行本次问卷调查。"
)}&questions=${encodeURIComponent(
  questions.join("#")
)}&options=${encodeURIComponent(optionString)}&types=${encodeURIComponent(
  typeString
)}`;
```

### 4. API 请求头优化

#### 原始实现：

- 缺少必要的请求头
- 签名和签名键设置不正确

#### 优化后实现：

```javascript
const response = await fetch(`${API_BASE_URL}/lgb/xfzwj/add`, {
  method: "POST",
  headers: {
    accept: "*/*",
    "accept-language": "zh-CN,zh;q=0.9",
    "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
    "sec-ch-ua":
      '"Not;A=Brand";v="99", "Google Chrome";v="139", "Chromium";v="139"',
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": '"macOS"',
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "same-origin",
    sign: sign, // 使用正确的签名
    signkey: signkey, // 使用正确的签名键
    "x-requested-with": "XMLHttpRequest",
  },
  credentials: "include",
  body: new URLSearchParams(questionnaireData),
});
```

### 5. 签名生成流程优化

#### 完整流程：

1. 获取动态盐值（`createDynamicsSalt`）
2. 生成问卷数据（包含 `encryptedText`）
3. 使用 `encryptedText` 和 `signkey` 生成签名
4. 发送请求时包含正确的 `sign` 和 `signkey` 头

```javascript
// 1. 获取动态盐值
const signkey = await createDynamicsSalt();

// 2. 生成问卷数据
const questionnaireData = generateQuestionnaireData(name, sex, answers);

// 3. 生成签名（使用encryptedText进行签名）
let sign;
if (typeof CryptoJS !== "undefined" && CryptoJS.HmacSHA256) {
  sign = CryptoJS.HmacSHA256(
    questionnaireData.encryptedText,
    signkey
  ).toString();
} else {
  const signResult = sign(signkey, questionnaireData.encryptedText);
  sign = hex(signResult);
}
```

## 与后端接口的对应关系

### 后端 `dcwj.js` 流程：

1. 调用 `../payMerge/createDynamicsSalt` 获取 `key`
2. 使用 `formatParams` 和 `toQueryString` 格式化数据
3. 调用 `hex(sign(key, value))` 生成签名
4. 发送 AJAX 请求，包含 `sign` 和 `signKey` 头

### 优化后的前端流程：

1. 调用 `createDynamicsSalt()` 获取 `signkey`
2. 使用 `generateQuestionnaireData()` 生成包含 `encryptedText` 的数据
3. 使用 `encryptedText` 和 `signkey` 生成签名
4. 发送 fetch 请求，包含 `sign` 和 `signkey` 头

## 文件说明

- **原始文件**: `/Users/yao/Yao/project/liuwei/html/js/automation-generator.js`
- **优化文件**: `/Users/yao/Yao/project/liuwei/html/js/automation-generator-optimized.js`

## 使用建议

1. 使用优化后的 `automation-generator-optimized.js` 替换原始文件
2. 确保页面加载了 `crypto-js` 库以获得最佳性能
3. 测试签名生成是否与后端验证一致
4. 监控 API 请求的成功率和错误信息

## 技术细节

### 签名算法兼容性：

- 优先使用 `CryptoJS.HmacSHA256`（如果可用）
- 提供备用的 JavaScript 实现
- 确保与后端 `crypto.js` 的 `sign` 和 `hex` 函数兼容

### 错误处理：

- 完善的 try-catch 错误处理
- 详细的日志输出便于调试
- 优雅的降级处理

### 性能优化：

- 减少不必要的字符串操作
- 优化数据编码过程
- 提供缓存机制（如需要）
